import json
import csv
import os
import re
from datetime import datetime

def normalize_name(name: str) -> str:
    """
    Creates a highly consistent "matching key" from a model name by removing
    all spaces, special characters, and standardizing terms.
    """
    # Convert to lowercase and strip whitespace
    clean_name = name.strip().lower()
    
    # Standardize common terms first
    clean_name = clean_name.replace('iwatch', 'watch')
    clean_name = clean_name.replace('prime 2', '')
    clean_name = clean_name.replace('on nxt', '')
    clean_name = clean_name.replace('on max', '')
    clean_name = clean_name.replace('on 8', '')
    
    # Remove all non-alphanumeric characters (spaces, slashes, hyphens, etc.)
    # This creates a very reliable key for matching.
    clean_name = re.sub(r'[^a-z0-9]', '', clean_name)
    
    return clean_name

def escape_sql_string(value: str) -> str:
    """Escapes single quotes for SQL insertion."""
    return value.replace("'", "''")

def parse_price(price_str: str) -> str:
    """
    Cleans and parses a currency string (e.g., '‚Çπ35,500.00') into a numeric SQL value.
    Returns 'NULL' if the string is invalid or empty.
    """
    if not price_str:
        return 'NULL'
    
    try:
        # Remove currency symbols, commas, and whitespace
        clean_str = price_str.replace('‚Çπ', '').replace(',', '').strip()
        
        # Convert to float
        price_float = float(clean_str)
        
        # Check if the number is a whole number (e.g., 3500.0)
        if price_float % 1 == 0:
            return str(int(price_float)) # Return as integer string '3500'
        else:
            return f"{price_float:.2f}" # Return as float string '3500.50'
            
    except (ValueError, TypeError):
        # If conversion fails, it's not a valid price
        return 'NULL'

def generate_sql_scripts():
    """
    Reads local data files and generates ordered SQL scripts for seeding the database.
    """
    print("üå± Starting SQL script generation...")
    
    # --- Branding for the SQL files ---
    generation_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    BRANDING_COMMENT = f"-- Generated by PixelPanic Seeding Script on {generation_time}\n"

    # --- Define keywords for models to skip ---
    SKIP_KEYWORDS = ['ipad', 'iwatch', 'macbook', 'watch']

    # --- 1. LOAD DATA FROM FILES ---
    try:
        with open('uploaded_media.json', 'r', encoding='utf-8') as f:
            uploaded_media = json.load(f)
        
        # Use the new CSV filename
        csv_filename = 'Final List-v1.csv'
        with open(csv_filename, 'r', encoding='utf-8') as f:
            reader = csv.reader(f)
            header = [h.strip() for h in next(reader)]
            # **FIX**: Manually assign the correct header name for the third column.
            header[2] = 'Issue' 
            
            price_list = [dict(zip(header, row)) for row in reader]
            
        print(f"‚úÖ Successfully loaded and cleaned data from JSON and '{csv_filename}'.")
    except FileNotFoundError as e:
        print(f"‚ùå Error: Could not find a required file. Make sure 'uploaded_media.json' and '{csv_filename}' are present. Details: {e}")
        return

    # --- Filter out skipped models from the media list ---
    filtered_media = [
        media for media in uploaded_media 
        if not any(keyword in media['model'].lower() for keyword in SKIP_KEYWORDS)
    ]
    print(f"‚ÑπÔ∏è  Filtered out non-phone models. Processing {len(filtered_media)} phone models.")


    # --- 2. GENERATE 01_insert_issues.sql ---
    print("\nGenerating script for 'issues' table...")
    issue_names = sorted(list(set(row['Issue'].strip() for row in price_list if row.get('Issue'))))
    
    with open('01_insert_issues.sql', 'w', encoding='utf-8') as f:
        f.write(BRANDING_COMMENT)
        f.write("-- Populates the 'issues' table with unique repair types.\n")
        f.write("-- Run this script first.\n\n")
        f.write("INSERT INTO issues (name) VALUES\n")
        values = [f"  ('{escape_sql_string(name)}')" for name in issue_names]
        f.write(',\n'.join(values))
        f.write("\nON CONFLICT (name) DO NOTHING;\n")
    print("‚úÖ Created '01_insert_issues.sql'")

    # --- 3. GENERATE 02_insert_models.sql ---
    print("\nGenerating script for 'models' table...")
    with open('02_insert_models.sql', 'w', encoding='utf-8') as f:
        f.write(BRANDING_COMMENT)
        f.write("-- Populates the 'models' table with phone models and their image URLs.\n")
        f.write("-- Run this script second, after populating 'issues'.\n\n")
        f.write("INSERT INTO models (name, brand_id, image_url) VALUES\n")
        values = []
        for media in filtered_media: # Use the filtered list
            model_name = escape_sql_string(media['model'])
            brand_name = escape_sql_string(media['brand'])
            image_url = escape_sql_string(media['imageUrl'])
            brand_id_subquery = f"(SELECT id FROM brands WHERE LOWER(name) = LOWER('{brand_name}'))"
            values.append(f"  ('{model_name}', {brand_id_subquery}, '{image_url}')")
        f.write(',\n'.join(values))
        f.write("\nON CONFLICT (brand_id, name) DO NOTHING;\n")
    print("‚úÖ Created '02_insert_models.sql'")

    # --- 4. GENERATE 03_insert_model_issues.sql (NEW EFFICIENT FORMAT) ---
    print("\nGenerating script for 'model_issues' (price matrix)...")
    
    valid_model_map = {normalize_name(media['model']): media['model'] for media in filtered_media}
    skipped_models = set()

    with open('03_insert_model_issues.sql', 'w', encoding='utf-8') as f:
        f.write(BRANDING_COMMENT)
        f.write("-- Populates the 'model_issues' price matrix using an efficient INSERT...SELECT statement.\n")
        f.write("-- Run this script last.\n\n")
        
        all_values = []
        current_brand = ''
        current_model = ''
        for row in price_list:
            issue_name = row.get('Issue', '').strip()
            if not issue_name:
                continue

            if row.get('Brand') and row['Brand'].strip():
                current_brand = row['Brand'].strip()
            if row.get('Model') and row['Model'].strip():
                current_model = row['Model'].strip()
            
            if any(keyword in current_model.lower() for keyword in SKIP_KEYWORDS):
                continue

            normalized_csv_model = normalize_name(current_model)

            if normalized_csv_model not in valid_model_map:
                if current_model not in skipped_models:
                    skipped_models.add(current_model)
                continue

            correct_model_name = valid_model_map[normalized_csv_model]
            
            original_price = parse_price(row.get("Original (OEM)"))
            aftermarket_price = 'NULL'

            # Append raw data for the VALUES clause
            all_values.append(f"  ('{escape_sql_string(correct_model_name)}', '{escape_sql_string(current_brand)}', '{escape_sql_string(issue_name)}', {original_price}, {aftermarket_price})")

        if all_values:
            f.write("INSERT INTO model_issues (model_id, issue_id, original_price, aftermarket_price)\n")
            f.write("SELECT m.id, i.id, mi.original_price::numeric, mi.aftermarket_price::numeric\n")
            f.write("FROM (VALUES\n")
            f.write(',\n'.join(all_values))
            f.write("\n) AS mi(model_name, brand_name, issue_name, original_price, aftermarket_price)\n")
            f.write("JOIN models m ON LOWER(m.name) = LOWER(mi.model_name)\n")
            f.write("JOIN brands b ON LOWER(b.name) = LOWER(mi.brand_name) AND m.brand_id = b.id\n")
            f.write("JOIN issues i ON LOWER(i.name) = LOWER(mi.issue_name)\n")
            f.write("ON CONFLICT (model_id, issue_id) DO NOTHING;\n")
        else:
            f.write("-- No valid price entries found to insert.\n")

    print("‚úÖ Created '03_insert_model_issues.sql'")
    if skipped_models:
        print("\n‚ö†Ô∏è  The following models from your CSV were skipped because they had no matching image or a name mismatch:")
        for model in sorted(list(skipped_models)):
            print(f"  - {model}")

    print("\nüéâ SQL script generation complete!")

if __name__ == "__main__":
    generate_sql_scripts()
